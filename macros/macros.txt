-- <<<<<<
-- ||||||v|
local counter=1
local n=12334
-- >>>>>>
-- <<<<<<
-- ||||||g|
function HTMLEntities(s)
    if not s then return "" end
    
    local result = {}
    local entities = {
        [' '] = "&nbsp;",
        ['<'] = "&lt;",
        ['>'] = "&gt;",
        ['&'] = "&amp;",
        ['"'] = "&quot;",
        ["'"] = "&apos;",
        ['¢'] = "&cent;",
        ['£'] = "&pound;",
        ['¥'] = "&yen;",
        ['€'] = "&euro;",
        ['©'] = "&copy;",
        ['®'] = "&reg;",
    }
    
    -- Iterate through each UTF-8 character
    for _, char in utf8.codes(s) do
        local utf8_char = utf8.char(char)
        local replacement = entities[utf8_char]
        
        if replacement then
            table.insert(result, replacement)
        else
            table.insert(result, utf8_char)
        end
    end
    
    return table.concat(result)
end
-- >>>>>>
-- <<<<<<
-- ||||||g|
function toXML(s)
    local n = #s
    local str = ""
    for i = 1, n do
        local r = s:sub(i,i)
        if r == "<" then
            r = "&lt;"
        elseif r == ">" then
            r = "&gt;"
        elseif r == "&" then
            r = "&amp;"
        elseif r == '"' then
            r = "&quot;"
        elseif r == "'" then
            r = "&apos;"
        end
        str = str .. r
    end
    return str
end
-- >>>>>>
-- <<<<<<
-- ||||||g|
function toHTML(s)
    local n = #s
    local str = ""
    for i = 1, n do
        local r = s:sub(i,i)
        if r == "<" then
            r = "&lt;"
        elseif r == ">" then
            r = "&gt;"
        elseif r == "&" then
            r = "&amp;"
        elseif r == '"' then
            r = "&quot;"
        elseif r == "'" then
            r = "&apos;"
        elseif r == "¢" then
            r = "&cent;"
        elseif r == "£" then
            r = "&pound;"
        elseif r == "¥" then
            r = "&yen;"
        elseif r == "€" then
            r = "&euro;"
        elseif r == "©" then
            r = "&copy;"
        elseif r == "®" then
            r = "&reg;"
        end
        str = str .. r
    end
    return str
end
-- >>>>>>
-- <<<<<<
-- ||||||g|
function toString(strList)
    local str = ''
    local len = #strList
    for i = 1, len do
        str = str .. strList[i]
    end
    return str
end
-- >>>>>>
-- <<<<<<
-- ||||||1|%
function outComment(pa, ar)
-- The content is a comment text and is not interpreted
local oList = {}
return oList
end
-- >>>>>>
-- <<<<<<
-- ||||||1|**
function outB(pa, ar)
-- inline bold
local oList = {}
table.insert(oList,'\1<span style="font-weight:bold">\4')
if type(pa) == "table" and #pa > 0 and type(pa[1]) == "table" and #pa[1]>0 then
  local p1 = pa[1]
  if type(p1[1]) == "string" then
    table.insert(oList, p1[1])
  end
end
table.insert(oList,'\1</span>\4')
return oList
end
-- >>>>>>
-- <<<<<<
-- ||||||1|//
function outI(pa, ar)
-- inline italic
local oList = {}
table.insert(oList,'\1<span style="font-style:italic">\4')
if type(pa) == "table" and #pa > 0 and type(pa[1]) == "table" and #pa[1]>0 then
  local p1 = pa[1]
  if type(p1[1]) == "string" then
    table.insert(oList, p1[1])
  end
end
table.insert(oList,'\1</span>\4')
return oList
end
-- >>>>>>
-- <<<<<<
-- ||||||1|__
function outU(pa, ar)
-- inline underlined
local oList = {}
table.insert(oList,'\1<span style="text-decoration:underline">\4')
if type(pa) == "table" and #pa > 0 and type(pa[1]) == "table" and #pa[1]>0 then
  local p1 = pa[1]
  if type(p1[1]) == "string" then
    table.insert(oList, p1[1])
  end
end
table.insert(oList,'\1</span>\4')
return oList
end
-- >>>>>>
-- <<<<<<
-- ||||||1|``
function outV(pa, ar)
-- inline verbatim (monospace)
local oList = {}
table.insert(oList,'\1<span style="font-family:monospace">\4')
if type(pa) == "table" and #pa > 0 and type(pa[1]) == "table" and #pa[1]>0 then
  local p1 = pa[1]
  if type(p1[1]) == "string" then
    table.insert(oList, p1[1])
  end
end
table.insert(oList,'\1</span>\4')
return oList
end
-- >>>>>>
-- <<<<<<
-- ||||||1|--
function outS(pa, ar)
-- inline strike-through
local oList = {}
table.insert(oList,'\1<span style="text-decoration:line-through">\4')
if type(pa) == "table" and #pa > 0 and type(pa[1]) == "table" and #pa[1]>0 then
  local p1 = pa[1]
  if type(p1[1]) == "string" then
    table.insert(oList, p1[1])
  end
end
table.insert(oList,'\1</span>\4')
return oList
end
-- >>>>>>
-- <<<<<<
-- ||||||1|''
function outT(pa, ar)
-- inline tagged the content is placed between <pre style="display: inline"> and </pre>
local oList = {}
table.insert(oList,'\1<pre style="display: inline">\4')
if type(pa) == "table" and #pa > 0 and type(pa[1]) == "table" and #pa[1]>0 then
  local p1 = pa[1]
  if type(p1[1]) == "string" then
    table.insert(oList, p1[1])
  end
end
table.insert(oList,'\1</pre>\4')
return oList
end
-- >>>>>>
-- <<<<<<
-- ||||||1|^
function outSup(pa, ar)
-- inline tagged
local oList = {}
table.insert(oList,'\1<sup>\4')
if type(pa) == "table" and #pa > 0 and type(pa[1]) == "table" and #pa[1]>0 then
  local p1 = pa[1]
  if type(p1[1]) == "string" then
    table.insert(oList, p1[1])
  end
end
table.insert(oList,'\1</sub>\4')
return oList
end
-- >>>>>>
-- <<<<<<
-- ||||||1|_
function outSub(pa, ar)
-- inline tagged
local oList = {}
table.insert(oList,'\1<sub>\4')
if type(pa) == "table" and #pa > 0 and type(pa[1]) == "table" and #pa[1]>0 then
  local p1 = pa[1]
  if type(p1[1]) == "string" then
    table.insert(oList, p1[1])
  end
end
table.insert(oList,'\1</sub>\4')
return oList
end
-- >>>>>>
-- <<<<<<
-- ||||||1|br
function outBr(pa, ar)
local oList = {}
    table.insert(oList,'\1')
    table.insert(oList, '<br>')
    table.insert(oList,'\4')
return oList
end
-- >>>>>>
-- <<<<<<
-- ||||||v|
-- Predefined color set for O(1) lookup
colorSet = {
    aliceblue = true, antiquewhite = true, aqua = true, aquamarine = true,
    azure = true, beige = true, bisque = true, black = true, blanchedalmond = true,
    blue = true, blueviolet = true, brown = true, burlywood = true, cadetblue = true,
    chartreuse = true, chocolate = true, coral = true, cornflowerblue = true,
    cornsilk = true, crimson = true, cyan = true, darkblue = true, darkcyan = true,
    darkgoldenrod = true, darkgray = true, darkgreen = true, darkgrey = true,
    darkkhaki = true, darkmagenta = true, darkolivegreen = true, darkorange = true,
    darkorchid = true, darkred = true, darksalmon = true, darkseagreen = true,
    darkslateblue = true, darkslategray = true, darkslategrey = true,
    darkturquoise = true, darkviolet = true, deeppink = true, deepskyblue = true,
    dimgray = true, dimgrey = true, dodgerblue = true, firebrick = true,
    floralwhite = true, forestgreen = true, fuchsia = true, gainsboro = true,
    ghostwhite = true, gold = true, goldenrod = true, gray = true, green = true,
    greenyellow = true, grey = true, honeydew = true, hotpink = true, indianred = true,
    indigo = true, ivory = true, khaki = true, lavender = true, lavenderblush = true,
    lawngreen = true, lemonchiffon = true, lightblue = true, lightcoral = true,
    lightcyan = true, lightgoldenrodyellow = true, lightgray = true, lightgreen = true,
    lightgrey = true, lightpink = true, lightsalmon = true, lightseagreen = true,
    lightskyblue = true, lightslategray = true, lightslategrey = true,
    lightsteelblue = true, lightyellow = true, lime = true, limegreen = true,
    linen = true, magenta = true, maroon = true, mediumaquamarine = true,
    mediumblue = true, mediumorchid = true, mediumpurple = true, mediumseagreen = true,
    mediumslateblue = true, mediumspringgreen = true, mediumturquoise = true,
    mediumvioletred = true, midnightblue = true, mintcream = true, mistyrose = true,
    moccasin = true, navajowhite = true, navy = true, oldlace = true, olive = true,
    olivedrab = true, orange = true, orangered = true, orchid = true, palegoldenrod = true,
    palegreen = true, paleturquoise = true, palevioletred = true, papayawhip = true,
    peachpuff = true, peru = true, pink = true, plum = true, powderblue = true,
    purple = true, rebeccapurple = true, red = true, rosybrown = true, royalblue = true,
    saddlebrown = true, salmon = true, sandybrown = true, seagreen = true, seashell = true,
    sienna = true, silver = true, skyblue = true, slateblue = true, slategray = true,
    slategrey = true, snow = true, springgreen = true, steelblue = true, tan = true,
    teal = true, thistle = true, tomato = true, turquoise = true, violet = true,
    wheat = true, white = true, whitesmoke = true, yellow = true, yellowgreen = true
}
-- >>>>>>
-- <<<<<<
-- ||||||g|
function isHTMLColor(colorStr)
    -- if type(colorStr) ~= "string" then return false end
    
    local color = colorStr:lower()
    
    -- Check hex format
    if color:match("^#%x%x%x%x%x%x$") or color:match("^#%x%x%x$") then
        return true
    end
    
    -- Check predefined colors
    return colorSet[color] or false
end
-- >>>>>>
-- <<<<<<
-- ||||||2|color|/color
function outColor(pa, ar)
local oList = {}
local col="yellow"
if type(pa) == "table" and #pa > 0 and type(pa[1]) == "table" and #pa[1]>0 then
  local p = pa[1]
  if type(p[1]) == "string" then
    if isHTMLColor(p[1]) then
      col=p[1]
    end
  end
end
table.insert(oList, '\1<span style="color: ' .. col .. ';">\4')
 if type(ar) == "table" and #ar > 0 and type(ar[1]) == "string" then
   table.insert(oList, ar[1])
 end
table.insert(oList, '\1</span>\4')
return oList
end
-- >>>>>>
-- <<<<<<
-- ||||||2|size|/size
function outSize(pa, ar)
    local y = '16px'
if type(pa) == "table" and #pa > 0 and type(pa[1]) == "table" and #pa[1]>0 then
  local p = pa[1]
  if type(p[1]) == "string" then
    y = p[1]
    -- Check if y contains a digit (y is a string, not table)
    -- local hasDigit = string.match(y, "%d") ~= nil
    -- if hasDigit then
    local num = tonumber(y)
    if num and num >= 20 and num <= 200 then
        -- y is between 20 and 200
       y = y .. '%'  -- Fixed: use .. for concatenation, not +=
    end
  end
end    
local x = ""
 if type(ar) == "table" and #ar > 0 and type(ar[1]) == "string" then
            x = ar[1]
 end
oList = {}
table.insert(oList, '\1<span style="font-size:\4' .. y .. '\1;">\4' .. x .. '\1</span>\4')
    return oList
end
-- >>>>>>
-- <<<<<<
-- ||||||2|==|/==
function outTitle(pa, ar)
    local oList = {}
    local x = '1'
    if type(pa) == "table" and #pa > 0 and type(pa[1]) == "table" and #pa[1] > 0 then
        local p = pa[1]
        if type(p[1]) == "string" then
          x = p[1]
          local num = '123456'
          if not num:find(x) then x = '1' end
        end
    end
    table.insert(oList,'\1')
    table.insert(oList, '<h' .. x .. '>')
    table.insert(oList,'\4')
    if type(ar) == "table" and #ar > 0 and type(ar[1]) == "string" then
        table.insert(oList, ar[1])
    end
    table.insert(oList,'\1')
    table.insert(oList, '</h' .. x .. '>')
    table.insert(oList,'\4')
    return oList
end
-- >>>>>>
-- <<<<<<
-- ||||||2|doc|/doc
function outDoc(pa, ar)
local oList = {}
local t='\1<!DOCTYPE html>\n<html>\n   <head>\n\4'
local c ='\1   </head>\n\n   <body>\4'
local b ='\1   </body>\n</html>\4'
table.insert(oList,t)
table.insert(oList,c)
if type(ar) == "table" and #ar > 0 and type(ar[1]) == "string" then
  table.insert(oList,ar[1])
end
table.insert(oList,b)
return oList
end
-- >>>>>>
-- <<<<<<
-- ||||||2|p|/p
function outP(pa, ar)
local oList = {}
table.insert(oList,'\1<p>\4')
if type(ar) == "table" and #ar > 0 and type(ar[1]) == "string" then
  local str=ar[1]
  table.insert(oList,str)
end
table.insert(oList,'\1</p>\4')
return oList
end
-- >>>>>>
-- <<<<<<
-- ||||||2|```|/```
function outVerbatimBlock(pa, ar)
-- verbatim block (monospace)
local oList = {}
table.insert(oList,'\1<pre>\4')
if type(ar) == "table" and #ar > 0 and type(ar[1]) == "string" then
  table.insert(oList,ar[1])
end
table.insert(oList, '\1</pre>\4')
return oList
end
-- >>>>>>
-- <<<<<<
-- ||||||2|'''|/'''
function outQuote(pa, ar)
local oList = {}
table.insert(oList, '\1<blockquote class="bg-gray primary">\4')
if type(ar) == "table" and #ar > 0 and type(ar[1]) == "string" then
  table.insert(oList,ar[1])
end
table.insert(oList, '\1</blockquote>\4')
return oList
end
-- >>>>>>
-- <<<<<<
-- ||||||2|---|/---
function outSource(pa, ar)
-- Source code block
local oList = {}
if type(ar) == "table" and #ar > 0 and type(ar[1]) == "string" then
  table.insert(oList, '\1')
  table.insert(oList,ar[1])
  table.insert(oList, '\4')
end
return oList
end
-- >>>>>>
-- <<<<<<
-- ||||||2|+++|/+++
function outPass(pa, ar)
-- Content in a passthrough block is protected by \1 and \4 characters.
local oList = {}
if type(ar) == "table" and #ar > 0 and type(ar[1]) == "string" then
  table.insert(oList, '\1')
  table.insert(oList,ar[1])
  table.insert(oList, '\4')
end
return oList
end
-- >>>>>>
-- <<<<<<
-- ||||||2|url|/url
function outURL(pa, ar)
    local oList = {}
    local ae = false
    local pe = false
    local p
    local a
    if type(pa) == "table" and #pa > 0 and type(pa[1]) == "table" and #pa[1]>0 then
      local p1 = pa[1]
      if type(p1[1]) == "string" then
          pe = true
          p = p1[1]
      end
    end
    if type(ar) == "table" and #ar > 0 and type(ar[1]) == "string" then
      ae = true
      a=ar[1]
    end
    local e = ae or pe
    if e then
        table.insert(oList, '\1<a href="\4')
        if pe then
          table.insert(oList, p)
          table.insert(oList, '\1">\4')
          table.insert(oList, a)
        else
          table.insert(oList, a)
          table.insert(oList, '\1">\4')
          table.insert(oList, p)
        end
        table.insert(oList, '\1</a>\4')
   else
     table.insert(oList, '\1<a href=""></a>\4')
  end
  return oList
end
-- >>>>>>
-- <<<<<<
-- ||||||3|!|*|/!
function outList(pa, ar)
        local oList = {}
        local b = '\1<ul>\4'
        local e = '\1</ul>\4'
        local x=''
   if type(pa) == "table" and #pa > 0 and type(pa[1]) == "table" and #pa[1] > 0 then
      local p = pa[1]
      if type(p[1]) == "string" then
        x = p[1]
      end
   end
    if x == '1' then
        b = '\1<ol style="list-style-type: decimal">\4'
        e = '\1</ol>\4'
    elseif x == 'a' then
        b = '\1<ol style="list-style-type: lower-alpha">\4'
        e = '\1</ol>\4'
    elseif x == 'A' then
        b = '\1<ol style="list-style-type: upper-alpha">\4'
        e = '\1</ol>\4'
    elseif x == 'i' then
        b = '\1<ol style="list-style-type: lower-roman">\4'
        e = '\1</ol>\4'
    elseif x == 'I' then
        b = '\1<ol style="list-style-type: upper-roman">\4'
        e = '\1</ol>\4'
    else
        b = '\1<ul>\4'
        e = '\1</ul>\4'
    end
    table.insert(oList, b)
    if type(ar) == "table" and #ar > 1 then
    local lenar=#ar
    for i=2,lenar do
      if type(ar[i]) == "string" then
        table.insert(oList, '\1<li>\4')
        table.insert(oList, ar[i])
        table.insert(oList, '\1</li>\4')
      end
    end 
    end
    table.insert(oList, e)
    return oList
end
-- >>>>>>
-- <<<<<<
-- ||||||g|
function options_from_parameters(parameters, element_type)
    -- Define valid options for each element type
    local valid_options = {
        table = { tborder = true},
        tr = { tbody = true, thead = true, tfoot = true },
        td = { h = true }
    }
    
    -- Get the valid options for this element type, or empty table if not found
    local options_lookup = valid_options[element_type] or {}
    local result = {}
    
    -- If parameters is not a table, return empty result
    if type(parameters) ~= "table" then
        return result
    end
    
    -- Process each parameter
    for _, param in ipairs(parameters) do
        -- Split on first equals sign
        local key, value = param:match("^([^=]*)=?(.*)$")
        
        if key and key ~= "" then
            -- Trim whitespace from key and value
            key = key:match("^%s*(.-)%s*$") or key
            value = value:match("^%s*(.-)%s*$") or value
            
            -- Check if this is a valid option for the element type
            if options_lookup[key] then
                -- If no value after =, set to true (or 1)
                if value == "" then
                    result[key] = true
                else
                    result[key] = value
                end
            end
        end
    end
    
    return result
end
-- >>>>>>
-- <<<<<<
-- ||||||g|
function split_on_first_equals(input_str)
    -- Handle nil or empty input
    if not input_str or input_str == "" then
        return nil, nil
    end

    -- Find the first occurrence of '=' in the string.
    -- `string.find` returns the start and end index of the found pattern.
    local first_equals_pos = string.find(input_str, "=", 1, true) -- The 'true' enables plain search, no patterns.

    if first_equals_pos == nil then
        -- If no '=' is found, return the whole string and an empty string for the right part.
        return input_str, ""
    else
        -- Extract the part to the left of the '=' (from start to pos-1)
        local left_part = string.sub(input_str, 1, first_equals_pos - 1)
        -- Extract the part to the right of the '=' (from pos+1 to the end)
        local right_part = string.sub(input_str, first_equals_pos + 1)
        return left_part, right_part
    end
end
-- >>>>>>
-- <<<<<<
-- ||||||v|
valid_attributes = {
    td = {
        colspan = true, rowspan = true, style = true, id = true,
        class = true, title = true, headers = true, scope = true
    },
    tr = {
        style = true, id = true, class = true, title = true,
        lang = true, dir = true, hidden = true, tabindex = true
    },
    table = {
        style = true, id = true, class = true, title = true,
        border = true, cellpadding = true, cellspacing = true,
        width = true, height = true, summary = true
    }
}
-- >>>>>>
-- <<<<<<
-- ||||||g|
function string_from_parameters(parameters, element_type)
    local valid_attrs = valid_attributes[element_type] or {}
    local attr_table = {}

    if type(parameters) ~= "table" or #parameters == 0 then
        return ""
    end

    for _, param in ipairs(parameters) do
        local key, value = split_on_first_equals(param)
        
        if key and value then
            key = key:match("^%s*(.-)%s*$") or ""
            value = value:match("^%s*(.-)%s*$") or ""
            
            if key ~= "" and value ~= "" and valid_attrs[key] then
                table.insert(attr_table, key .. '="' .. value .. '"')
            end
        end
    end

    if #attr_table > 0 then
        return " " .. table.concat(attr_table, " ")
    else
        return ""
    end
end
-- >>>>>>
-- <<<<<<
-- ||||||6|###|##|#|/###
function outTable(pa, ar, po)
    local oList = {}
    -- Validate input
    if not po or #po == 0 or po[1] ~= 1 or po[#po] ~= 4 then
        return oList
    end

    local total_twos = 0
    local total_threes = 0
    local threes_after_twos = {}
    local two_positions = {}
    
    -- First pass: find all positions of 2s
    for i = 1, #po do
        if po[i] == 2 then
            total_twos = total_twos + 1
            two_positions[total_twos] = i
        end
    end
    
    -- For each 2, count 3s between it and the next 2 (or end)
    for i = 1, total_twos do
        local start_pos = two_positions[i] + 1
        local end_pos = two_positions[i + 1] and (two_positions[i + 1] - 1) or (#po - 1)
        
        threes_after_twos[i] = 0
        
        -- Count 2s in the range between current 1 and next 1/end
        for j = start_pos, end_pos do
            if po[j] == 3 then
                total_threes = total_threes + 1
                threes_after_twos[i] = threes_after_twos[i] + 1
            end
        end
    end
    
    -- Find maximum number of 2s after any 3
    local max_threes = 0
    for i = 1, #threes_after_twos do
        if threes_after_twos[i] > max_threes then
            max_threes = threes_after_twos[i]
        end
    end

    local is_pa_table = pa and type(pa)=="table" and #pa>0
    table.insert(oList, '\1<table')
    if is_pa_table and pa[1] and type(pa[1])=="table" and #pa[1]>0 then
        local str_table = string_from_parameters(pa[1], "table")
        table.insert(oList, str_table)
    end
    table.insert(oList, '>\4')

if type(ar) == "table" and #ar > total_threes + 1 then
        if is_pa_table then 
            local i, j, k = 1, 1, 1
            local current_section = nil
            
            for i = 1, total_twos do
                k = k + 1
                local current_options = options_from_parameters(pa[two_positions[i]], "tr")
                
                -- ?1: Handle section starts BEFORE the current row (same as before)
                if current_options["thead"] then
                    if current_options["thead"] == "<" or current_options["thead"] == "1" then
                        if current_section then
                            table.insert(oList, "\1</" .. current_section .. ">\4")
                        end
                        table.insert(oList, "\1<thead>\4")
                        current_section = "thead"
                    end
                end
                
                if current_options["tbody"] then
                    if current_options["tbody"] == "<" or current_options["tbody"] == "1" then
                        if current_section then
                            table.insert(oList, "\1</" .. current_section .. ">\4")
                        end
                        table.insert(oList, "\1<tbody>\4")
                        current_section = "tbody"
                    end
                end
                
                if current_options["tfoot"] then
                    if current_options["tfoot"] == "<" or current_options["tfoot"] == "1" then
                        if current_section then
                            table.insert(oList, "\1</" .. current_section .. ">\4")
                        end
                        table.insert(oList, "\1<tfoot>\4")
                        current_section = "tfoot"
                    end
                end
                
                -- Print the current row (same as before)
                table.insert(oList, '\1<tr>\4')
                for j = 1, max_threes do
                    if j <= threes_after_twos[i] then
                        k = k + 1
                        local td = '\1<td'
                        local tdb = '>\4'
                        local tde = '\1</td>\4'
                        local str_td = ""
                        
                        if pa[k] and type(pa[k])=="table" and #pa[k]>0 then
                            local td_options = options_from_parameters(pa[k], "td")
                            if td_options["h"] ~= nil then
                                td = '\1<th'
                                tde = '\1</th>\4'
                            end
                            str_td = string_from_parameters(pa[k], "td")
                        end
                        
                        table.insert(oList, td)
                        if str_td ~= "" then
                            table.insert(oList, str_td)
                        end
                        table.insert(oList, tdb)
                        
                        if type(ar[k]) == "string" then
                            table.insert(oList, ar[k])
                        end
                        
                        table.insert(oList, tde)
                    else
                        table.insert(oList, '\1<td>\4')
                        table.insert(oList, '\1</td>\4')    
                    end
                end
                table.insert(oList, '\1</tr>\4')
                
                -- ?2: NEW - Handle section ends AFTER the current row's content
                -- This makes the end markers inclusive (the row is inside the section)
                if current_options["thead"] and current_options["thead"] == ">" and current_section == "thead" then
                    table.insert(oList, "\1</thead>\4")
                    current_section = nil
                end
                
                if current_options["tbody"] and current_options["tbody"] == ">" and current_section == "tbody" then
                    table.insert(oList, "\1</tbody>\4")
                    current_section = nil
                end
                
                if current_options["tfoot"] and current_options["tfoot"] == ">" and current_section == "tfoot" then
                    table.insert(oList, "\1</tfoot>\4")
                    current_section = nil
                end
            end
            
            -- After processing all rows, close any remaining open section
            if current_section then
                table.insert(oList, "\1</" .. current_section .. ">\4")
            end
        end
    end
    
    table.insert(oList, '\1</table>\4')    
    return oList
end
-- >>>>>>
-- <<<<<<
-- ||||||2|@|/@
function outEmail(pa, ar)
    local oList = {}
    local ae = false
    local pe = false
    local p
    local a
 if type(pa) == "table" and #pa > 0 and type(pa[1]) == "table" and #pa[1] > 0 then
      if type(pa[1][1]) == "string" then
        pe=true
        p = pa[1][1]
      end
   end
   if type(ar) == "table" and #ar > 0 and type(ar[1]) == "string" then
        ae = true
        a = ar[1]
    end
    local e = ae or pe
    if ae and not pe then
        p = a
    end
    if not ae and pe then
        a = p
    end
    if e ~="" then
        table.insert(oList, '\1<a href="mailto:\4')
        table.insert(oList, p)
        table.insert(oList, '\1">\4')
        table.insert(oList, a)
        table.insert(oList, '\1</a>\4')
    else
        table.insert(oList, '\1<a href="mailto:">\4')
        table.insert(oList, '\1</a>\4')
    end
    return oList
end
-- >>>>>>
-- <<<<<<
-- ||||||2|nofollow|/nofollow
function outNofollow(pa, ar)
    local oList = {}
    local ae = false
    local pe = false
    local a
    local p
    if type(pa) == "table" and #pa > 0 and type(pa[1]) == "table" and #pa[1]>0 then
      local p1 = pa[1]
      if type(p1[1]) == "string" then
            pe = true
            p = p1[1]
      end
    end
    if type(ar) == "table" and #ar > 0 and type(ar[1]) == "string" then
        ae = true
        a=ar[1]
    end
    local e = ae or pe
    if ae and not pe then
        p = a
    end
    if not ae and pe then
        a = p
    end
    if e then
        table.insert(oList, '\1<a href="\4')
        table.insert(oList, p)
        table.insert(oList, '\1" rel="nofollow">\4')
        table.insert(oList, a)
        table.insert(oList, '\1</a>\4')
    else
        table.insert(oList, '\1<a href="" rel="nofollow">\4')
        table.insert(oList, '\1</a>\4')
    end
    return oList
end
-- >>>>>>
-- <<<<<<
-- ||||||1|img
function outImg(pa, ar)
    local oList = {}
    table.insert(oList, '\1<img src="\4')
   if type(pa) == "table" and #pa > 0 and type(pa[1]) == "table" and #pa[1]>0  then
    local p=pa[1]
    if type(p[1]) == "string" then
        local src = p[1]
        local alt = p[2]
        table.insert(oList, src)
        table.insert(oList, '\1" alt="\4')
        table.insert(oList, alt)
        table.insert(oList, '\1" />\4')
    else
       table.insert(oList, '\1<img src="" alt=""/>\4')
    end
   else
       table.insert(oList, '\1<img src="" alt=""/>\4')
   end 
    return oList
end
-- >>>>>>
-- <<<<<<
-- ||||||2|code|/code
function outCode(pa, ar)
local oList = {}
table.insert(oList, '\1<code>\4')
if type(ar) == "table" and #ar > 0 and type(ar[1]) == "string" then
table.insert(oList,ar[1])
end
table.insert(oList, '\1</code>\4')
return oList
end
-- >>>>>>
-- <<<<<<
-- ||||||2|htm|/htm
function outHtm(pa, ar)
    local oList = {}
    if type(ar) == "table" and #ar > 0 and type(ar[1]) == "string" then
       table.insert(oList,ar[1])
    end    
    return oList
end
-- >>>>>>
-- <<<<<<
-- ||||||1|command
function outCommand(pa, ar)
    local oList = {}
    table.insert(oList, '\1<span class="command">\4')
    if type(pa) == "table" and #pa > 0 and type(pa[1]) == "table" and #pa[1] > 0 then
        local p = pa[1]
        if type(p[1]) == "string" then
                        table.insert(oList, p[1])
                end
            end
    table.insert(oList, '\1</span>\4')
    return oList
end
-- >>>>>>
-- <<<<<<
-- ||||||1|language
function outLanguage(pa, ar)
    local oList = {}
    table.insert(oList, '\1<span class="language">\4')
    if type(pa) == "table" and #pa > 0 and type(pa[1]) == "table" and #pa[1] > 0 then
        local p = pa[1]
        if type(p[1]) == "string" then
                        table.insert(oList, p[1])
                end
            end
    table.insert(oList, '\1</span>\4')
    return oList
end
-- >>>>>>
-- <<<<<<
-- ||||||1|file
function outFile(pa, ar)
    local oList = {}
    table.insert(oList, '\1<span class="file">\4')
    if type(pa) == "table" and #pa > 0 and type(pa[1]) == "table" and #pa[1] > 0 then
        local p = pa[1]
        if type(p[1]) == "string" then
                        table.insert(oList, p[1])
                end
            end
    table.insert(oList, '\1</span>\4')
    return oList
end
-- >>>>>>
-- <<<<<<
-- ||||||1|extension
function outExtension(pa, ar)
    local oList = {}
    table.insert(oList, '\1<span class="file">\4')
    if type(pa) == "table" and #pa > 0 and type(pa[1]) == "table" and #pa[1] > 0 then
        local p = pa[1]
        if type(p[1]) == "string" then
                        table.insert(oList, p[1])
                end
            end
    table.insert(oList, '\1</span>\4')
    return oList
end
-- >>>>>>
-- <<<<<<
-- ||||||1|directory
function outDirectory(pa, ar)
    local oList = {}
    table.insert(oList, '\1<span class="directory">\4')
    if type(pa) == "table" and #pa > 0 and type(pa[1]) == "table" and #pa[1] > 0 then
        local p = pa[1]
        if type(p[1]) == "string" then
                        table.insert(oList, p[1])
                end
            end
    table.insert(oList, '\1</span>\4')
    return oList
end
-- >>>>>>
-- <<<<<<
-- ||||||1|path
function outPath(pa, ar)
    local oList = {}
    table.insert(oList, '\1<span class="path">\4')
    if type(pa) == "table" and #pa > 0 and type(pa[1]) == "table" and #pa[1] > 0 then
        local p = pa[1]
        if type(p[1]) == "string" then
                        table.insert(oList, p[1])
                end
            end
    table.insert(oList, '\1</span>\4')
    return oList
end
-- >>>>>>
-- <<<<<<
-- ||||||1|trademark
function outTrademark(pa, ar)
    local oList = {}
    table.insert(oList, '\1<span class="trademark">\4')
    if type(pa) == "table" and #pa > 0 and type(pa[1]) == "table" and #pa[1] > 0 then
        local p = pa[1]
        if type(p[1]) == "string" then
                        table.insert(oList, p[1])
                end
            end    
    table.insert(oList, '\1</span>\4')
    return oList
end
-- >>>>>>
-- <<<<<<
-- ||||||1|item
function outItem(pa, ar)
    local oList = {}
    table.insert(oList, '\1<span class="item">\4')
    if type(pa) == "table" and #pa > 0 and type(pa[1]) == "table" and #pa[1] > 0 then
        local p = pa[1]
        if type(p[1]) == "string" then
                        table.insert(oList, p[1])
                end
            end
    table.insert(oList, '\1</span>\4')
    return oList
end
-- >>>>>>
-- <<<<<<
-- ||||||1|iurl
function outIurl(pa, ar)
    local oList = {}
    table.insert(oList, '\1<span class="url">\4')
    if type(pa) == "table" and #pa > 0 and type(pa[1]) == "table" and #pa[1] > 0 then
        local p = pa[1]
        if type(p[1]) == "string" then
                        table.insert(oList, p[1])
                end
            end
    table.insert(oList, '\1</span>\4')
    return oList
end
-- >>>>>>
-- <<<<<<
-- ||||||1|example
function outExample(pa, ar)
    local oList = {}
    table.insert(oList, '\1<span class="definition">\4')
    if type(pa) == "table" and #pa > 0 and type(pa[1]) == "table" and #pa[1] > 0 then
        local p = pa[1]
        if type(p[1]) == "string" then
                        table.insert(oList, p[1])
                end
            end
    table.insert(oList, '\1</span>\4')
    return oList
end
-- >>>>>>
-- <<<<<<
-- ||||||1|definition
function outDefinition(pa, ar)
    local oList = {}
    table.insert(oList, '\1<span class="definition">\4')
    if type(pa) == "table" and #pa > 0 and type(pa[1]) == "table" and #pa[1] > 0 then
        local p = pa[1]
        if type(p[1]) == "string" then
                        table.insert(oList, p[1])
                end
            end
    table.insert(oList, '\1</span>\4')
    return oList
end
-- >>>>>>
-- <<<<<<
-- ||||||1|output
function outOutput(pa, ar)
    local oList = {}
    table.insert(oList, '\1<span class="output">\4')
    if type(pa) == "table" and #pa > 0 and type(pa[1]) == "table" and #pa[1] > 0 then
        local p = pa[1]
        if type(p[1]) == "string" then
                        table.insert(oList, p[1])
                end
            end
    table.insert(oList, '\1</span>\4')
    return oList
end
-- >>>>>>
-- <<<<<<
-- ||||||2|output-box|/output-box
function outOutputBox(pa, ar)
    local oList = {}
    table.insert(oList, '\1<div class="output-box">\4')
    if type(ar) == "table" and #ar > 0 and type(ar[1]) == "string" then
       table.insert(oList,ar[1])
    end
    table.insert(oList, '\1</div>\4')
    return oList
end
-- >>>>>>
-- <<<<<<
-- ||||||1|input
function outInput(pa, ar)
    local oList = {}
    table.insert(oList, '\1<span class="input">\4')
    if type(pa) == "table" and #pa > 0 and type(pa[1]) == "table" and #pa[1] > 0 then
        local p = pa[1]
        if type(p[1]) == "string" then
                        table.insert(oList, p[1])
                end
            end
    table.insert(oList, '\1</span>\4')
    return oList
end
-- >>>>>>
-- <<<<<<
-- ||||||2|input-box|/input-box
function outInputBox(pa, ar)
    local oList = {}
    table.insert(oList, '\1<div class="input-box">\4')
    if type(ar) == "table" and #ar > 0 and type(ar[1]) == "string" then
       table.insert(oList,ar[1])
    end
    table.insert(oList, '\1</div>\4')
    return oList
end
-- >>>>>>
-- <<<<<<
-- ||||||2|icode|/icode
function outOcode(pa, ar)
    local oList = {}
    table.insert(oList, '\1<code>\4')
    if type(ar) == "table" and #ar > 0 and type(ar[1]) == "string" then
       table.insert(oList,ar[1])
    end        
    table.insert(oList, '\1</code>\4')
    return oList
end
-- >>>>>>
-- <<<<<<
-- ||||||2|definition-box|/definition-box
function outDefinitionBox(pa, ar)
    local oList = {}
    table.insert(oList, '\1<div class="definition">\4')
    if type(ar) == "table" and #ar > 0 and type(ar[1]) == "string" then
       table.insert(oList,ar[1])
    end
    table.insert(oList, '\1</div>\4')
    return oList
end
-- >>>>>>
-- <<<<<<
-- ||||||1|hr
function outHr(pa, ar)
return ({'\1<hr />\4'})
end
-- >>>>>>
-- <<<<<<
-- ||||||2|em|/em
function outEm(pa, ar)
    local oList = {}
    table.insert(oList, '\1<em>\4')
    if type(ar) == "table" and #ar > 0 and type(ar[1]) == "string" then
       table.insert(oList,ar[1])
    end    
    table.insert(oList, '\1</em>\4')
    return oList
end
-- >>>>>>
-- <<<<<<
-- ||||||1|sp
function outSp(pa, ar)
    local oList = {}
    local x = 1
    -- Check if p has content (Lua is 1-indexed)
    if type(pa) == "table" and #pa > 0 and type(pa[1]) == "table" and #pa[1] > 0 then
        local p = pa[1]
        if type(p[1]) == "string" then
          x = tonumber(p[1])
          if not x then
            x=1
          end
        end
    end
    -- Add non-breaking spaces
    for i = 1, x do  -- Start at 1, go up to x
        table.insert(oList, '\1&nbsp;\4')
    end
    return oList
end
-- >>>>>>