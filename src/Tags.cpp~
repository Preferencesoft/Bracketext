// Bracketext.cpp : définit le point d'entrée de l'application.
//

#include "Tags.h"

using namespace std;


    /*
     * tagNumber/tag
        None -1
        String -2
        OpenBracket -3
        ClosedBracket -4
        StraightLine -5

    */

    const int nString = -1; // string in parameters
    const int nResult = -2; // during a conversion, certain character strings should only be converted once
    const int nOpenBracket = -3;
    const int nClosedBracket = -4;
    const int nStraightLine = -5;
    const int nParameterBlocks = -7; // contains a complete tag
    const int nArguments = -8; // contains a complete tag
    const int nGroup = -9; // groups together successions of tags and strings (without [ | ])
    const int nTag = -6; // tag
    const int nMATag = -11; // tag argument to complete
    const int nNone = -12;
    // we do not define a tag when the parameters are not complete

    std::vector< std::vector<std::wstring>> Tags::tagInfoList;
    std::vector<std::wstring> Tags::commandList;
    std::vector<std::wstring> Tags::functionNameList;
    std::vector<std::wstring> Tags::scriptList;
    std::vector<std::vector<int>> Tags::tagAssociationList;
    std::vector<std::wstring> Tags::tagList;
    std::vector<int> Tags::tagEntryList;
    std::vector<int> Tags::tagTypeList;
    std::vector<int> Tags::tagPositionList;
    std::vector<Tags::Entity> Tags::document;

    /*
    struct Entity
    {
        public int tagNumber;
        public string str; //nul when the entity is a tag
        // public List<Parameter> parameterList;
        public vector<Tags::Entity> entityList;
    }
    */

    // Tag association table
    // 0 undefined
    // 1 SINGLE (macro or function)
    // 2 BEGIN_END
    // 3 BEGIN_MIDDLE_END (deleted)
    // 4 BEGIN_REPEATED_MIDDLE_END
    // 5 BEGIN_REPEATED_AT_LEAST_ONCE_MIDDLE_END
    // (not yet implemented)
    // 6 MULTIPLE_REPEATED_MIDDLE_BLOCKS

    const int TUndefined = 0;
    const int TSingle = 1;
    const int TBeginEnd = 2;
    const int TBeginMiddleEnd = 3;
    const int TBeginRepeatedMiddleEnd = 4;

    const int TMultipleRepeatedMiddleBlocks = 6;

    // Tag types in the same association.
    // "/" Beginning
    // "1", ..., "9" from 1 to 9 intermediate tag number
    // only "1" and "2" are currently being used
    // "." end

    const std::wstring Tags::TB = L"/";
    const std::wstring Tags::TE = L".";

    /*
     * List that was originally used for testing.
     *
    List<string[]> tagInfoList = new List<string[]>
    {
        new string[]{ "1", "Hello"},
        new string[]{ "2", "title", "/title"},
        new string[]{ "2", "h1", "/h1"},
        new string[]{ "2", "h2","/h2"},
        new string[]{ "2", "h3","/h3"},
        new string[]{ "2", "h4","/h4"},
        new string[]{ "2", "h5","/h5"},
        new string[]{ "2", "h6","/h6"},
        new string[]{ "2", "b","/b"},
        new string[]{ "2", "i","/i"},
        new string[]{ "2", "u","/u"},
        new string[]{ "2", "s","/s"},
        new string[]{ "2", "size","/size"},
        new string[]{ "2", "style","/style"},
        new string[]{ "2", "color","/color"},
        new string[]{ "2", "center", "/center"},
        new string[]{ "2", "left","/left"},
        new string[]{ "2", "right","/right"},
        new string[]{ "2", "quote","/quote"},
        new string[]{ "2", "url","/url"},
        new string[]{ "2", "img","/img"},
        new string[]{ "2", "ul","/ul"},
        new string[]{ "2", "ol","/ol"},
        new string[]{ "2", "li","/li"},
        new string[]{ "2", "code","/code"},
        new string[]{ "2", "table","/table"},
        new string[]{ "2", "tr","/tr"},
        new string[]{ "2", "th","/th"},
        new string[]{ "2", "td","/td"},
        new string[]{ "2", "youtube", "/youtube"},
        new string[]{ "3", "li","-", "/li"},
        new string[]{ "4", "list","*", "/list"},
    };
    */
    std::wstring Tags::SubStr(std::wstring& s, int n) {
        return (s.size() >= n ? s.substr(0, n) : L"");
    }

    std::wstring Tags::readFile(const char* filename)
    {
        std::wifstream wif(filename);
        wif.imbue(std::locale("en_US.UTF-8"));
        std::wstringstream wss;
        wss << wif.rdbuf();
        return wss.str();
    }

    std::vector<std::wstring> Tags::split(const std::wstring& s, const wchar_t delimiter)
    {
        std::vector<std::wstring> tokens;
        std::wstring token;
        std::wistringstream tokenStream(s);
        while (std::getline(tokenStream, token, delimiter))
        {
            tokens.push_back(token);
        }
        return tokens;
    }

    std::wstring Tags::Trim(std::wstring& str) {
        int i = 0;
        int j = str.length()-1;
        bool move = true;
        while (i < j && move) {
            if (str[i] == ' ') ++i;
            else move = false;
        }
        move = true;
        while (i < j && move) {
                if (str[j] == ' ') --j;
                else move = false;
        }
        if (i == j) {
            if (str[i] == ' ') return L"";
            else return str.substr(i, 1);
        }
        if (i < j) return str.substr(i, j - i + 1);
        else return L"";
    }
   
    void Tags::LoadMacros(std::string psFileName) {
        // provisionally, we load the entire text.
       //  std::wstring[] text = File.ReadAllText(psFileName, Encoding.UTF8).Split('\n');
        std::wstring wstr = readFile(psFileName);
        vector<std::wstring> text = split(wstr, L'\n');
        int state = 0;
        std::wstringstream sb;
        // 0 no function
        // 1 header
        // 2 inside the function
        for (int i = 0; i < text.size(); i++)
        {
            if (state == 0)
            {
                if (Trim(text[i]) != L"// <<<<<<")
                    continue;
                state++;
            }
            else
            {
                if (state == 1)
                {
                    // beginning of a function
                    wstring header = Trim(text[i]);
                    if (header.substr(0, 9) != L"// ||||||")
                        continue;
                    header = header.substr(9);
                    auto entry = split(header, L'|');
                    bool isGlobal = false;
                    if (entry.size() > 0)
                    {
                        if (entry[0] == L"g")
                            isGlobal = true;
                    }
                    if (isGlobal)
                    {
                        sb.clear();
                        state = 4;
                        // pass 2 and 3
                    }
                    else
                    {
                        tagInfoList.push_back(entry);
                        state++;
                        // goto 2
                    }
                }
                else
                {
                    if (state == 2)
                    {
                        auto fun = Trim(text[i]);
                        if (SubStr(fun, 9) != L"function ")
                            continue;
                        fun = fun.substr(9);
                        int ind = fun.find_first_of('(');
                        fun = fun.erase(ind);

                        functionNameList.push_back(fun);
                        sb.clear();
                        sb << Trim(text[i]);
                        state++;
                    }
                    else
                    {
                        if (state == 3)
                        {
                            if (Trim(text[i]) != L"// >>>>>>")
                            {
                                sb << Trim(text[i]);
                                continue;
                            }
                            else
                            {
                                Tags::commandList.push_back(sb.str());
                                state = 0;
                            }
                        }
                        else
                        {
                            if (state == 4)
                            {
                                if (Trim(text[i]) != L"// >>>>>>")
                                {
                                    sb << Trim(text[i]);
                                    continue;
                                }
                                else
                                {
                                    Tags::scriptList.push_back(sb.str());
                                    state = 0;
                                }
                            }
                        }
                    }
                }
            }

        }
    }
  
   
    bool CompareString(Tags::info i1, Tags::info i2)
    {
        return (i1.sep < i2.sep);
    }
   
    
        void Tags::Init()
        {
            // List<System.Tuple<string, int, int>> tupleList = new List<System.Tuple<string, int, int>>();
            vector<info> infoList;
            int sepListCount = Tags::tagInfoList.size();
            //tagAssociationList = new int[sepListCount][];
            //tagTypeList = new int[sepListCount];
            for (int n = 0; n < sepListCount; n++)
            {
                vector<std::wstring> sep = Tags::tagInfoList[n];
                int len = sep.size();
                for (int i = 1; i < len; i++)
                {
                    infoList.push_back(Tags::info { sep[i], 0,  i });
                        //.Add(System.Tuple.Create<string, int, int>(sep[i], n, i));
                }
            }
            // sort by string
            ///////////////////////////////////////////////sort(infoList.begin(), infoList.end(), CompareString);
            int tupleListCount = infoList.size();
            // tagList = new string[tupleListCount];
            // tagEntryList = new int[tupleListCount];
            // tagPositionList = new int[tupleListCount];
            
            for (int i = 0; i < tupleListCount; i++)
            {
                auto t = infoList[0];
                Tags::tagList[i] = t.sep;
                Tags::tagEntryList[i] = t.entry;
                Tags::tagPositionList[i] = t.pos;
                infoList.erase(infoList.begin());
            }
            
            for (int n = 0; n < sepListCount; n++)
            {
                vector<std::wstring> separ = Tags::tagInfoList[n];
                int len = separ.size();
                tagAssociationList[n] = std::vector<int>(len - 1);
                for (int i = 1; i < len; i++)
                {
                    auto lower = std::lower_bound(tagList.begin(), tagList.end(), separ[i]);
                    int index = std::distance(tagList.begin(), lower);
                    tagAssociationList[n][i - 1] = index;
                }
                int e = std::stoi(separ[0]);
                tagTypeList[n] = e;
            }
        }
        

        bool Tags::IsNotDelim(wchar_t c)
        {
            switch (c)
            {
            case '[':
            case ']':
            case '|':
                return false;
            }
            return true;
        }

        bool Tags::IsNotSymbol(wchar_t c)
        {
            switch (c)
            {
            case '[':
            case ']':
            case '|':
            case '`':
                return false;
            }
            return true;
        }

        int Tags::CharToTagNumber(wchar_t c)
        {
            switch (c)
            {
            case '[':
                return nOpenBracket;
            case ']':
                return  nClosedBracket;
            case '|':
                return  nStraightLine;
            }
            return  nNone;
        }

        std::wstring Tags::TagNumberToWString(int t)
        {
            switch (t)
            {
            case nOpenBracket:
                return L"[";
            case nClosedBracket:
                return L"]";
            case nStraightLine:
                return L"|";
            case nString:
                return L"s";
            case nTag:
                return L"t";
            case nGroup:
                return L"g";
            case nParameterBlocks:
                return L"p";
            case nArguments:
                return L"a";
            }
            return L" ";
        }

        // Delete CR characters
        // but actually does nothing.
        std::wstring Tags::CleanTag(std::wstring& t)
        {
            return t;
        }


        void Tags::BBCodeToTree()
        {
            // search for the tags without parameters [command]
            for (int i = 0; i < document.size() - 2; i++)
            {
                if (document[i].tagNumber == nOpenBracket
                    && document[i + 1].tagNumber == nString
                    && document[i + 2].tagNumber == nClosedBracket
                    )
                {
                    // searching for the tag
                    std::wstring t = CleanTag(document[i + 1].str);
                    // int tNumber = Array.BinarySearch(tagList, t);
                    auto lower = std::lower_bound(tagList.begin(), tagList.end(), t);
                    int tNumber = std::distance(tagList.begin(), lower);
                    if (tNumber >= 0)
                    {
                        document[i] = Tags::Entity
                        {
                            nMATag,
                            nullptr,
                            vector<Tags::Entity>
                            {
                                Tags::Entity
                                {
                                    tNumber,
                                    nullptr,
                                    vector<Tags::Entity>
                                    {
                                        Tags::Entity
                                        {
                                            nParameterBlocks,
                                            TE,
                                            vector<Tags::Entity>()
                                        }
                                    }
                                }
                            }
                        };
                        document.erase(document.begin() + i + 1);
                        document.erase(document.begin() + i + 1);
                    }
                }
            }
            // DisplayEntity(document);
            // reduction
            bool notEnded = true;
            while (notEnded)
            {
                notEnded = false;
                // grouping inside parameters |...| or |...] or ]...]
                // We group together packets made up exclusively of nTag, nString and nGroup
                bool modified = true;
                while (modified)
                {
                    int i = 0;
                    modified = false;
                    while (i < document.size() - 1)
                    {
						bool found = true;
                        switch (document[i].tagNumber)
                        {
                        case nClosedBracket:
                            found = false;
                            int j;
                            for (j = i + 1; j < document.size(); j++)
                            {
                                int tn = document[j].tagNumber;
                                //if (tn == nClosedBracket || tn == nOpenBracket)
                                if (tn == nClosedBracket)
                                {
                                    found = true;
                                    break;
                                }
                                else
                                    if (tn != nTag && tn != nString && tn != nGroup)
                                        break;
                            }
                            if (found)
                            {
                                ReductionG(i, j, modified);
                                notEnded = modified;
                            }
                            break;
                        case nStraightLine:
                            found = false;
                            for (j = i + 1; j < document.size(); j++)
                            {
                                int tn = document[j].tagNumber;
                                if (tn == nClosedBracket || tn == nStraightLine)
                                {
                                    found = true;
                                    break;
                                }
                                else
                                    if (tn != nTag && tn != nString && tn != nGroup)
                                        break;
                            }
                            if (found)
                            {
                                ReductionG(i, j, modified);
                                notEnded = modified;
                            }
                            break;
                        }
                        i++;
                    }
                }
                // DisplayEntity(document);

                // scan [string|group|...|group]
                int ii = 0;
                int tNum = 0;
                while (ii < document.size() - 5)
                {
                    if (document[ii].tagNumber == nOpenBracket
                        && document[ii + 1].tagNumber == nString
                        && document[ii + 2].tagNumber == nStraightLine)
                    {
                        // searching for the tag
                        std::wstring t = CleanTag(document[ii + 1].str);
                        // tNum = Array.BinarySearch(tagList, t);
                        auto lower = std::lower_bound(tagList.begin(), tagList.end(), t);
                        tNum = std::distance(tagList.begin(), lower);

                        bool foundInstruction = false;
                        int j = 0;
                        if (tNum >= 0)
                        {
                            for (j = ii + 3; j < document.size() - 1; j += 2)
                            {
                                if (document[j].tagNumber == nGroup)
                                {
                                    if (document[j + 1].tagNumber == nStraightLine)
                                        continue;
                                    else
                                        if (document[j + 1].tagNumber == nClosedBracket)
                                        {
                                            j += 2;
                                            foundInstruction = true;
                                        }
                                }
                                break;
                            }
                        }
                        if (foundInstruction)
                        {
                            notEnded = true;
                            Tags::Entity e = Tags::Entity
                            {
                                nMATag,
                                nullptr,
                                vector<Tags::Entity>
                                {
                                    Tags::Entity
                                    {
                                        tNum,
                                        nullptr,
                                        vector<Tags::Entity>
                                        {
                                            Tags::Entity
                                            {
                                                nParameterBlocks,
                                                TE,
                                                // By default, the first parameter block is defined as terminal TE
                                                vector<Tags::Entity>()
                                            }
                                        }
                                    }
                                }
                            };
                            for (int k = ii + 3; k < j; k += 2)
                                e.entityList[0].entityList[0].entityList.push_back(document[k]);
                            for (int k = ii + 1; k < j; k++)
                                document.erase(document.begin() + ii + 1);
                            document[ii] = e;
                        }
                    }
                    ii++;
                }
                // DisplayEntity(document);

                // Search for complete associated tags [begin] ... [end] and others
                modified = true;
                while (modified)
                {
                    modified = false;
                    ii = 0;
                    while (ii < document.size())
                    {
                        if (document[ii].tagNumber == nMATag)
                        {
                            Entity tag = document[ii].entityList[0];
                            int position = tagPositionList[tag.tagNumber];
                            //string s = tagList[tag.tagNumber];
                            if (position == 1)
                            {
                                // When the position equals 1, we have a starting tag [begin]
                                int entry = tagEntryList[tag.tagNumber];
                                int type = tagTypeList[entry];
                                vector<int> asso = tagAssociationList[entry];
                                int last = asso.size() - 1;
                                bool f = false;
                                switch (type)
                                {
                                    // See the tag association table, above.
                                case TSingle:
                                {
                                    modified = true;
                                    notEnded = true;
                                    Entity newTag = Tags::Entity
                                    {
                                        nTag,
                                        nullptr,
                                        document[ii].entityList
                                        // We're retrieving the parameter block from the current tag.
                                    };
                                    newTag.entityList[0].entityList.push_back(
                                        Tags::Entity
                                        {
                                            nArguments,
                                            nullptr,
                                            vector<Tags::Entity>()
                                        });
                                    // No argument here
                                    document[ii] = newTag;
                                }
                                break;
                                case TBeginEnd:
                                {
                                    int j;
                                    for (j = ii + 1; j < document.size(); j++)
                                    {
                                        int tn = document[j].tagNumber;
                                        if (tn == nMATag)
                                        {
                                            if (document[j].entityList[0].tagNumber == asso[last])
                                            {
                                                f = true;
                                                break;
                                            }
                                            else
                                                break;
                                        }
                                        else
                                            if (tn != nString && tn != nTag)
                                                break;
                                    }
                                    if (f)
                                    {
                                        modified = true;
                                        notEnded = true;
                                        Reduction1(ii, j);
                                    }
                                }
                                break;
                                case TBeginMiddleEnd:
                                case TBeginRepeatedMiddleEnd:
                                {
                                    int count = 0;
                                    int j;
                                    for (j = ii + 1; j < document.size(); j++)
                                    {
                                        int tn = document[j].tagNumber;
                                        if (tn == nMATag)
                                        {
                                            if (document[j].entityList[0].tagNumber == asso[last])
                                            {
                                                f = true;
                                                break;
                                            }
                                            else
                                                if (document[j].entityList[0].tagNumber != asso[last - 1])
                                                    break;
                                                else count++;
                                        }
                                        else
                                            if (tn != nString && tn != nTag)
                                                break;
                                    }
                                    if (type == TBeginRepeatedMiddleEnd && count == 0)
                                        f = false;
                                    if (f)
                                    {
                                        modified = true;
                                        notEnded = true;
                                        if (count == 0)
                                            Reduction1(ii, j);
                                        else
                                            Reduction2(ii, j, last, asso);
                                    }
                                }
                                break;
                                case TMultipleRepeatedMiddleBlocks:
                                {
                                    int count = 0;
                                    int j;
                                    for (j = ii + 1; j < document.size(); j++)
                                    {
                                        int tn = document[j].tagNumber;
                                        if (tn == nMATag)
                                        {
                                            if (document[j].entityList[0].tagNumber == asso[last])
                                            {
                                                f = true;
                                                break;
                                            }
                                            else
                                            {
                                                bool isIntermediateTag = false;
                                                for (int k = 1; k < last; k++)
                                                {
                                                    if (document[j].entityList[0].tagNumber == asso[k])
                                                    {
                                                        isIntermediateTag = true;
                                                        break;
                                                    }
                                                }
                                                if (!isIntermediateTag)
                                                    break;
                                                else count++;
                                            }
                                        }
                                        else
                                            if (tn != nString && tn != nTag)
                                                break;
                                    }
                                    if (f)
                                    {
                                        modified = true;
                                        notEnded = true;
                                        if (count == 0)
                                            Reduction1(ii, j);
                                        else
                                            Reduction2(ii, j, last, asso);
                                    }
                                }
                                break;
                                }
                            }
                        }
                        ii++;
                    }
                }
            }

            // *** Test ***

            // DisplayEntity(document);
        }
    

        // Reduced to form a group.
        void Tags::ReductionG(int& i, int j, bool& modified)
        {
            modified = false;
            // case already one group
            if (j - i == 2)
                if (document[i + 1].tagNumber == nGroup)
                    return;
            modified = true;
            if (j - i >= 2)
            {
                Tags::Entity gr = Tags::Entity
                {
                    nGroup,
                    nullptr,
                    vector<Entity>()
                };
                for (int k = i + 1; k < j; k++)
                {
                    if (document[k].tagNumber == nGroup)
                        // gr.entityList.AddRange(document[k].entityList);
                    gr.entityList.insert(gr.entityList.end(), document[k].entityList.begin(), document[k].entityList.end());
                    else
                        gr.entityList.push_back(document[k]);
                }
                for (int k = i + 2; k < j; k++)
                    document.erase(document.begin() + i + 1);
                document[i + 1] = gr;
                ++i;
            }
            else
            {
                document.insert(document.begin() + i + 1,
                    Tags::Entity
                    {
                        nGroup,
                        nullptr,
                        vector<Tags::Entity>
                        {
                            Tags::Entity
                            {
                                nString,
                                nullptr,
                                vector<Tags::Entity>()
                            }
                        }
                    }
                );
                ++i;
            }
        }

        void Tags::Reduction1(int ii, int j)
        {
            // The argument is removed
            Entity argumentGroup = Tags::Entity
            {
                nGroup,
                nullptr,
                vector<Tags::Entity>()
            };
            for (int k = ii + 1; k < j; k++)
                argumentGroup.entityList.push_back(document[k]);
            for (int k = ii + 1; k < j; k++)
                document.erase(document.begin() + ii + 1);
            // The parameters of the two tags
            Entity newTag = Tags::Entity
            {
                nTag,
                nullptr,
                vector<Entity>
                                            {
                                               Tags::Entity
                                               {
                                                   document[ii].entityList[0].tagNumber,
                                                   nullptr,
                                                   vector<Entity>()
                                               }
                                            }
            };
            vector<Tags::Entity> param = document[ii].entityList[0].entityList;
            if (param.empty())
            {
                // newTag.entityList[0].entityList.AddRange(param);
                newTag.entityList[0].entityList.push_back(Tags::Entity
                    {
                        nParameterBlocks,
                        TB,
                        param[0].entityList
                    });
                // The first block is of the beginning type.
            }
            param = document[ii + 1].entityList[0].entityList;
            if (param.empty())
                // newTag.entityList[0].entityList.AddRange(param);
                newTag.entityList[0].entityList.push_back(Tags::Entity
                    {
                        nParameterBlocks,
                        TE,
                        param[0].entityList
                    });
            newTag.entityList[0].entityList.push_back(
                Tags::Entity
                {
                    nArguments,
                    nullptr,
                    vector<Entity> { argumentGroup }
                }
            );
            document[ii] = newTag;
            document.erase(document.begin() + ii + 1);
        }

        void Tags::Reduction2(int ii, int j, int last, std::vector<int> asso)
        {
            Entity newTag = Tags::Entity
            {
                nTag,
                nullptr,
                vector<Tags::Entity>
                                            {
                                               Tags::Entity
                                               {
                                                   document[ii].entityList[0].tagNumber,
                                                   nullptr,
                                                   vector<Tags::Entity>()
                                               }
                                            }
            };


            vector<Tags::Entity> argumentList; // = new vector<Tags::Entity>();
            Entity subGroup = Tags::Entity
            {
                nGroup,
                nullptr,
                vector<Tags::Entity>()
            };
            if (document[ii].entityList[0].entityList.empty())
            {
                newTag.entityList[0].entityList.push_back(Tags::Entity
                    {
                        nParameterBlocks,
                        Tags::TB,
                        document[ii].entityList[0].entityList[0].entityList
                    });
                // The first block is of the beginning type.
            }
            for (int k = ii + 1; k <= j; k++)
            {
                int tn = document[k].tagNumber;
                if (tn == nMATag)
                {
                    auto tg = document[k].entityList[0].tagNumber;
                    bool isIntermediateTag = false;
                    std::wstring tagType = TE;
                    if (tg == asso[last])
                        isIntermediateTag = true;
                    else
                    {
                        for (int a = last - 1; a > 0; a--)
                        {
                            if (tg == asso[a])
                            {
                                tagType = ((wchar_t)(a + 48));// .ToString();
                                isIntermediateTag = true;
                                break;
                            }
                        }
                    }
                    if (isIntermediateTag)
                    {
                        if (document[k].entityList[0].entityList.empty())
                        {
                            // newTag.entityList[0].entityList.AddRange(document[k].entityList[0].entityList);
                            newTag.entityList[0].entityList.push_back(Tags::Entity
                                {
                                    nParameterBlocks,
                                    tagType,
                                    document[k].entityList[0].entityList[0].entityList
                                });
                        }
                        argumentList.push_back(subGroup);
                        subGroup = Tags::Entity
                        {
                            nGroup,
                            nullptr,
                            vector<Entity>()
                        };
                        continue;
                    }
                }
                subGroup.entityList.push_back(document[k]);
            }
            for (int k = ii + 1; k <= j; k++)
                document.erase(document.begin() + ii + 1);
            newTag.entityList[0].entityList.push_back(
                Tags::Entity
                {
                    nArguments,
                    nullptr,
                    argumentList
                });
            document[ii] = newTag;
            //document.RemoveAt(ii + 1);
        }





        std::wstring Tags::TagToString(Tags::Entity e)
        {
            switch (e.tagNumber)
            {
            case nStraightLine:
                return L"|";
            case nOpenBracket:
                return L"[";
            case nClosedBracket:
                return L"]";
            case nString:
                return e.str;
            case nMATag:
                return L"[not recognized tag]";
            }
            return L"[error] {0}" + e.tagNumber;
        }

        vector<std::wstring> Tags::ToStringArrayList(vector<Tags::Entity> le, vector<int> index)
        {
            vector<std::wstring> res;
            int i = -1;
            std::wstring str = L"";
            if (index.size() > 0) str = to_wstring(index[0]);
            for (int j = 1; j < index.size(); j++)
                str += L"," + to_wstring(index[j]);
            for (Tags::Entity e : le)
            {
                if (e.tagNumber == nResult)
                {
                    i++;
                    res.push_back(str + L"," + to_wstring(i));
                    res.push_back(to_wstring(nResult));
                    i++;
                    res.push_back(str + L"," + to_wstring(i));
                    res.push_back(e.str);
                }
                else
                {
                    i++;
                    res.push_back(str + L"," + to_wstring(i));
                    res.push_back(to_wstring(nString));
                    i++;
                    res.push_back(str + L"," + to_wstring(i));
                    res.push_back(TagToString(e));
                }
            }
            return res;
        }

        vector<std::wstring> Tags::GetParameters(Tags::Entity tag)
        {
            vector<std::wstring> args;
            //List<string[][]> args = new List<string[][]>();
            vector<std::wstring> pars;
            vector<std::wstring> par;
            if (tag.tagNumber == nTag)
            {
                vector<Tags::Entity> pList = tag.entityList[0].entityList;
                vector<int> indexP = { 0, -1, -1 };
                // parameter indexes
                vector<int> indexA = { 1, -1 };
                // argument indexes
                int indexT = -1;
                // type index
                for (Tags::Entity pa : pList)
                {
                    if (pa.tagNumber == nParameterBlocks)
                    {
                        indexT++;
                        pars.push_back(L"2,{0}" + indexT);
                        pars.push_back(L"" + pa.str);
                        if (!pa.entityList.empty())
                        {
                            indexP[1]++;
                            // vector<std::wstring> ls = new vector<std::wstring>();
                            par.clear();
                            for (Tags::Entity grp : pa.entityList)
                            {
                                if (!grp.entityList.empty())
                                {
                                    indexP[2]++;
                                    // par.AddRange(ToStringArrayList(grp.entityList, indexP));
                                    par.insert(par.end(), ToStringArrayList(grp.entityList, indexP).begin(), ToStringArrayList(grp.entityList, indexP).end());
                                }
                            }
                            //pars.AddRange(par.ToArray());
                            pars.insert(pars.end(), par.begin(), par.end());
                        }
                    }
                    if (pa.tagNumber == nArguments)
                    {
                        if (!pa.entityList.empty())
                        {
                            for (Tags::Entity gra : pa.entityList)
                            {
                                if (gra.entityList.empty()) continue;
                                indexA[1]++;
                                // pars.AddRange(ToStringArrayList(gra.entityList, indexA));
                                pars.insert(pars.end(), ToStringArrayList(gra.entityList, indexA).begin(), ToStringArrayList(gra.entityList, indexA).end());
                            }
                        }
                    }
                }
            }
            return pars;
        }


        std::wstring Tags::DocumentToHTML()
        {
            std::wstring sb = L"";
            for (Tags::Entity e : document)
            {
                sb += e.str;
            }
            return sb;
        }

        std::wstring Tags::HTMLEntities(std::wstring s)
        {
            int n = s.length();
            std::wstring str = L"";
            for (int i = 0; i < n; i++)
            {
                auto res = (std::wstring)(&s[i]);
                switch (s[i])
                {
                case L' ':
                    res = L" ";
                    break;
                case L'<':
                    res = L"&lt;";
                    break;
                case L'>':
                    res = L"&gt;";
                    break;
                case L'&':
                    res = L"&amp;";
                    break;
                case L'"':
                    res = L"&quot;";
                    break;
                case L'\'':
                    res = L"&apos;";
                    break;
                case L'¢':
                    res = L"&cent;";
                    break;
                case L'£':
                    res = L"&pound;";
                    break;
                case L'¥':
                    res = L"&yen;";
                    break;
                case L'€':
                    res = L"&euro;";
                    break;
                case L'©':
                    res = L"&copy;";
                    break;
                case L'®':
                    res = L"&reg;";
                    break;
                }
                str += res;
            }
            return str;
        }

        // Replace symbol tag ([, |, ]) by a <string>
        void Tags::SymbolTagToString(vector<Tags::Entity> eList, int pos)
        {
            switch (eList[pos].tagNumber)
            {
            case nStraightLine:
            case nOpenBracket:
            case nClosedBracket:
                eList[pos] = Tags::Entity
                {
                    nString,
                    TagNumberToWString(eList[pos].tagNumber),
                    vector<Tags::Entity>()
                };
                break;
            }
        }

        void Tags::SymbolTagToHTML(vector<Tags::Entity> eList, int pos)
        {
            switch (eList[pos].tagNumber)
            {
            case nStraightLine:
            case nOpenBracket:
            case nClosedBracket:
                eList[pos] = Tags::Entity
                {
                    nString,
                    Tags::TagNumberToWString(eList[pos].tagNumber),
                    vector<Tags::Entity>()
                };
                break;
            case nString:
            case nResult:
                eList[pos] = Tags::Entity
                {
                    nString,
                    HTMLEntities(eList[pos].str),
                    vector<Tags::Entity>()
                };
                break;
            }
        }

        std::wstring Tags::StringifyMATag(Tags::Entity e)
        {
            // we loop into parameters
            std::wstring sb = L"[";
            if (e.tagNumber <= 0)
            {
                sb += tagList[e.entityList[0].tagNumber];
                vector<Tags::Entity> pList = e.entityList[0].entityList;
                // parameter list
                for (int j = 0; j < pList.size(); j++)
                {
                    Entity pa = pList[j];
                    if (pa.tagNumber == nParameterBlocks)
                    {
                        if (!pa.entityList.empty())
                        {
                            for (Tags::Entity pb : pList[j].entityList)
                            {
                                if (!pb.entityList.empty())
                                {
                                    for (Tags::Entity grp : pb.entityList)
                                    {
                                        if (grp.entityList.empty())
                                        {
                                            for (int l = 0; l < grp.entityList.size(); l++)
                                            {
                                                // add elements
                                                sb += L"|";
                                                sb += grp.entityList[l].str;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    /*
                    if (pa.tagNumber == nArguments)
                    {
                        if (pa.entityList != null)
                        {
                            foreach (Entity gra in pa.entityList)
                            {
                                if (gra.entityList != null)
                                {
                                    for (int l = 0; l < gra.entityList.size(); l++)
                                    {

                                    }
                                }
                            }
                        }
                    }
                    */
                }
                sb += L"]";
            }
            return sb;
        }

        struct Position
        {
        public:
            vector<Tags::Entity> list;
            int index;
        };




        void Tags::EvalTree()
        {
            //IJsEngineSwitcher engineSwitcher = JsEngineSwitcher.Current;

      // initialization
		// create new Lua state
     lua_State *L = luaL_newstate();
    
    // Test normal function bind
    // state.set("lambda", &getHello);
    // assert(strcmp(state["lambda"](), getHello()) == 0);
    
    // Test lambda captures
    bool flag = false;
    // state->set("lambda", [&flag]() { flag = true; } );
    // state->doString("lambda()");
    // assert(flag == true);
			
            vector<vector<Position>> tagListList;
            int level = 0;
            tagListList.push_back(vector<Position>());
            for (int i = 0; i < document.size(); i++)
            {
                auto doc = document;
                if (document[i].tagNumber == nTag
                    || document[i].tagNumber == nMATag)
                    tagListList[level].push_back(Position{document, i });
                else
                    SymbolTagToString(doc, i);
            }
            // descent to the innermost tags
            while (true)
            {
                if (tagListList[level].size() == 0)
                    break;
                level++;
                tagListList.push_back(vector<Position>());
                for (Position pos : tagListList[level - 1])
                {
                    Entity e = pos.list[pos.index];
                    if (e.tagNumber <= 0)
                    {
                        vector<Tags::Entity> pList = e.entityList[0].entityList;
                        for (int j = 0; j < pList.size(); j++)
                        {
                            Entity pa = pList[j];
                            if (pa.tagNumber == nParameterBlocks)
                            {
                                if (!pa.entityList.empty())
                                {
                                    for (Tags::Entity pb : pList[j].entityList)
                                    {
                                        if (!pb.entityList.empty())
                                        {
                                            for (Tags::Entity grp : pb.entityList)
                                            {
                                                if (!grp.entityList.empty())
                                                {
                                                    for (int l = 0; l < grp.entityList.size(); l++)
                                                    {
                                                        if (grp.entityList[l].tagNumber == nTag
                                                            || grp.entityList[l].tagNumber == nMATag)
                                                            tagListList[level].push_back(
                                                                Position
                                                                {
                                                                    grp.entityList,
                                                                    l
                                                                });
                                                        else
                                                            SymbolTagToString(grp.entityList, l);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            if (pa.tagNumber == nArguments)
                            {
                                if (!pa.entityList.empty())
                                {
                                    for (Tags::Entity gra : pa.entityList)
                                    {
                                        if (gra.entityList.empty())
                                        {
                                            for (int l = 0; l < gra.entityList.size(); l++)
                                            {
                                                if (gra.entityList[l].tagNumber == nTag
                                                    || gra.entityList[l].tagNumber == nMATag)
                                                    tagListList[level].push_back(
                                                        Position
                                                        {
                                                            gra.entityList,
                                                            l
                                                        });
                                                else
                                                    SymbolTagToString(gra.entityList, l);
                                                //SymbolTagToHTML(gra.entityList, l);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            reverse(tagListList.begin(), tagListList.end());
            vector<std::wstring> results;
            std::wstring bigScript = L"";
            for (std::wstring script : scriptList)
            {
                bigScript += script + L"\n";
            }
            for (std::wstring script : commandList)
            {
                bigScript += script + L"\n";
            }

            // engineSwitcher.EngineFactories.AddChakraCore();
            // engineSwitcher = JsEngineSwitcher.Current;
            //engineSwitcher.DefaultEngineName = ChakraCoreJsEngine.EngineName;
            //// engineSwitcher.EngineFactories.Add(new ChakraCoreJsEngineFactory());
            //// IPrecompiledScript precompiledCode = null;
			
            // using (var engine = engineSwitcher.CreateDefaultEngine())
            {
				/*
                if (!engine.SupportsScriptPrecompilation)
                {
                    Console.WriteLine("{0} версии {1} не поддерживает " +
                        "предварительную компиляцию скриптов!",
                        engine.Name, engine.Version);
                    return;
                }
			*/
                //try
                {
                    // precompiledCode = engine.Precompile(bigScript);
                    // engine.Execute(bigScript);
                    for (vector<Position> pList : tagListList)
                    {
                        reverse(pList.begin(), pList.end());
                        for (Position p : pList)
                        {
                            auto tagNum = p.list[p.index].entityList[0];
                            int entry = tagEntryList[tagNum.tagNumber];
                            auto tag = p.list[p.index];
                            if (tag.tagNumber == nTag)
                            {
                                std::vector<std::wstring> args = GetParameters(tag);
                                auto d = Data();
                                 //auto res0 = engine.CallFunction(functionNameList[entry], args);
                                std::wstring res0;
								std::vector<std::wstring> r = d.Deserialize(res0);
                                // post execution?
                                // deals with load instruction 
                                if (r.size() > 1)
                                {
                                    if (r[0] == to_wstring(nNone)
                                        && (r[1] != L" "))
                                    {
                                        int c = r.size();
                                        for (int ind = 2; ind < c; ind += 2)
                                        {
                                            if (ind + 3 < c)
                                            {
                                                if (r[ind] == to_wstring(nNone)
                                                    && r[ind + 1] == L"load")
                                                {
                                                    /////////////// std::wstring text = Tags::readFile((r[ind + 3]));
std::wstring text;
														r[ind] = to_wstring(nResult);
                                                    r[ind + 1] = text;
                                                    r.erase(r.begin() + ind + 2);
                                                    r.erase(r.begin() + ind + 2);
                                                    c -= 2;
                                                }
                                            }
                                        }
                                        r.erase(r.begin());
                                        r.erase(r.begin());
                                    }
                                }
                                vector<Tags::Entity> res1;
                                for (int i = 0; i < r.size(); i += 2)
                                {
                                    res1.push_back(
                                        Tags::Entity
                                        {
                                            std::stoi(r[i]),
                                            r[i + 1],
									        std::vector<Tags::Entity>()
                                        });
                                }
                                auto res = res1;
                                /*
                                    powershell.AddCommand(functionNameList[entry])
                                        .AddParameter("param", GetParameters(tag).param)
                                        .AddParameter("arg", GetParameters(tag).arg);
                                  */
                                  /*
                                     powershell.AddCommand(functionNameList[entry])
                                           .AddParameter("param", tag.entityList[0].entityList)
                                           .AddParameter("arg", GetParameters(tag).arg);
                                           */
                                           // var res = powershell.Invoke();
                                vector<Tags::Entity> le;
                                for (int i = 0; i < res.size(); i++)
                                {
                                    // if (res[i] != null)
                                    {
                                        //try
                                        {
                                            le.push_back(Tags::Entity
                                                {
                                                    res[i].tagNumber,
                                                    res[i].str,
                                                    vector<Tags::Entity>()
                                                });
                                        }
                                        /*
                                        catch()
                                        {
                                            wcout << L"error in " << functionNameList[entry];
                                        }
                                        */
                                    }
                                }
                                //p.list.(p.index);
                                //p.list.InsertRange(p.index, le);
                                /*
                                    for (int i=0; i<res.size(); i++)
                                    {
                                        if (res[i] != null)
                                        {
                                            try
                                            {
                                                le.Add(new Entity()
                                                {
                                                    tagNumber = (int)res[i].Members["tagNumber"].Value,
                                                    str = res[i].Members["str"].Value.ToString(),
                                                    entityList = null
                                                });
                                            } catch
                                            {
                                                Console.WriteLine("error in "+ functionNameList[entry]);
                                            }
                                        }
                                    }
                                    p.list.RemoveAt(p.index);
                                    p.list.InsertRange(p.index, le);
                                    */
                            }
                            else
                            {
                                // nMATag
                                p.list[p.index] = Tags::Entity 
								{
                                    nString,
                                    StringifyMATag(tag),
                                    std::vector<Tags::Entity>()
                                };
                            }

                            // DisplayEntity(document);
                        }

                    }
                }
                // catch (JsException e)
                {
                    wcout << L"Во время работы JavaScript-движка произошла " <<  "ошибка!";
                    wcout << endl;
                    // wcout << JsErrorHelpers.GenerateErrorDetails(e));
                    return;
                }
      // close the Lua state
    lua_close(L);
                // DisplayEntity(document);
            }
        }
        void Tags::DisplayEntity(vector<Tags::Entity> document)
        {
            if (!document.empty())
            {
                for (Tags::Entity e : document)
                {

                    if (e.tagNumber < 0)
                    {
                        switch (e.tagNumber)
                        {
                        case nNone:
                            wcout << L">>>>>None";
                            break;
                        case nString:
                            wcout <<  L">>>>>" <<  e.str;
                            break;
                        case nOpenBracket:
                            wcout <<  L">>>>>" << e.str;
                            break;
                        case nClosedBracket:
                            wcout << L">>>>>" << e.str;
                            break;
                        case nStraightLine:
                            wcout << L">>>>>{0}" << e.str;
                            break;
                        case nTag:
                            wcout <<  L">>>>>BEGIN TAG";
                            DisplayEntity(e.entityList);
                            wcout << L">>>>>END TAG";
                            break;
                        case nMATag:
                            wcout << L">>>>>BEGIN MATAG";
                            DisplayEntity(e.entityList);
                            wcout << ">>>>>END MATAG";
                            break;
                        case nParameterBlocks:
                            wcout << L">>>>>BEGIN PARAMETER BLOCK";
                            DisplayEntity(e.entityList);
                            wcout << ">>>>>END PARAMETER BLOCK";
                            break;
                        case nArguments:
                            wcout << L">>>>>BEGIN ARGUMENTS";
                            DisplayEntity(e.entityList);
                            wcout << L">>>>>END ARGUMENTS";
                            break;
                        case nGroup:
                            wcout << L">>>>>BEGIN GROUP";
                            DisplayEntity(e.entityList);
                            wcout << L">>>>>END GROUP";
                            break;
                        }

                    }
                    else
                    {
                        wcout << L"tag" << tagList[e.tagNumber];
                        if (!e.entityList.empty())
                        {
                            wcout << L">>>>>>>>>>";
                            DisplayEntity(e.entityList);
                            wcout << L">>>>>>>>>>";
                        }
                    }
                }
            }
        }
        void Tags::ScanFile(std::string fileName)
        {
			// const wchar_t *input = fileName.c_str();
			std::string s = fileName;
			//std::wstring input(s.begin(), s.end());
			std::wstring text = readFile(fileName);
/*
// Count required buffer size (plus one for null-terminator).
size_t size = (wcslen(input) + 1) * sizeof(wchar_t);
char *buffer = new char[size];

#ifdef __STDC_LIB_EXT1__
    // wcstombs_s is only guaranteed to be available if __STDC_LIB_EXT1__ is defined
    size_t convertedSize;
    std::wcstombs_s(&convertedSize, buffer, size, input, size);
#else
    std::wcstombs(buffer, input, size);
#endif
*/
/* Use the string stored in "buffer" variable */
/*
// Free allocated memory:
delete buffer;
           
            std::wstring text = readFile(buffer);
			*/
            wcout << text;
            int textLength = text.length();
            std::wstring sb = L"";
            int i = 0;
            while (i < textLength)
            {
                wchar_t c = text[i];
                if (IsNotDelim(c))
                {
                    // retrieve the string
                    sb = L"";
                    while (i < textLength)
                    {
                        c = text[i];
                        if (IsNotSymbol(c))
                            sb += c;
                        else
                        {
                            if (c == L'`')
                            {
                                if (++i < textLength)
                                {
                                    c = text[i];
                                    if (IsNotSymbol(c))
                                    {
                                        sb += L"`";
                                        sb += c;
                                    }
                                    else
                                    {
                                        // no ` before [ ] | `
                                        sb += c;
                                    }
                                }
                                else
                                {
                                    sb += L"`";
                                }
                            }
                            else
                                break;
                        }
                        ++i;
                    }
                    std::wstring s = sb;
                    document.push_back(
                        Tags::Entity
                        {
                            nString,
                            s,
                            vector<Tags::Entity>()
                        });
                    --i;
                    // Console.WriteLine(">> {0}", sb.ToString());
                }
                else
                {
                    // [ or ] or | is a delim
                    document.push_back(
                        Tags::Entity
                        {
                            CharToTagNumber(c),
                            (std::wstring)(&c),
                            vector<Tags::Entity>()
                        });
                    //Console.WriteLine("[ or ] or |");
                }
                ++i;
            }
            // *** Test ***
            /*
            foreach (Entity e in document)
            {
                if (e.tagNumber<0)
                Console.WriteLine("type:{0}",  CharToTagNumber(e.tagNumber));
                else
                    Console.WriteLine("type:{0}", tagList[e.tagNumber]);
                Console.WriteLine(">>>>>{0}", e.str);
            }
            */
        }